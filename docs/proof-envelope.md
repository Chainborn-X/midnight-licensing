# Proof Envelope Format

## Overview

The **Proof Envelope** is the canonical JSON format for distributing Midnight license proofs in a portable, secure, and extensible manner. It wraps zero-knowledge proof data with all necessary metadata for offline validation in .NET applications.

## Purpose

The proof envelope enables:

- **Portable Proof Distribution**: Transfer proofs from customer proof generation environments to runtime containers
- **Offline Validation**: Verify licenses locally without external API calls
- **Anti-Replay Protection**: Challenge/nonce mechanism prevents proof reuse
- **Extensibility**: Support for future ZK system enhancements and metadata fields
- **Multi-Source Loading**: Load proofs from environment variables, files, or Kubernetes secrets

## Schema Reference

The canonical JSON Schema is located at: `policies/schemas/proof-envelope.schema.json`

All proof envelopes MUST validate against this schema before being processed by the .NET validator.

## Field Definitions

### Required Fields

#### `proofBytes` (string)

- **Type**: String (base64-encoded)
- **Description**: The actual zk-SNARK proof data containing serialized elliptic curve points
- **Encoding**: Base64
- **Size**: Typically < 1 KB for Groth16 proofs
- **Usage**: This is the cryptographic proof generated by the Midnight proof server that attests to license ownership
- **⚠️ Security**: This field is sensitive. Do NOT log proof bytes in production environments

**Example:**
```json
"proofBytes": "AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8w..."
```

#### `verificationKeyBytes` (string)

- **Type**: String (base64-encoded)
- **Description**: Verification key containing G1 and G2 elliptic curve group elements required to verify the proof
- **Encoding**: Base64
- **Size**: Several KB (circuit-specific)
- **Usage**: The verification key is derived from the circuit's trusted setup. It must match the circuit used to generate the proof
- **Distribution**: Typically bundled with the application or fetched during deployment

**Example:**
```json
"verificationKeyBytes": "gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp..."
```

#### `productId` (string)

- **Type**: String
- **Description**: Unique product identifier that this proof is valid for
- **Usage**: Must match the `productId` in the license policy. Used to ensure proofs cannot be reused across different products
- **Format**: Alphanumeric string, typically kebab-case

**Example:**
```json
"productId": "chainborn-sample-app"
```

#### `challenge` (object)

Challenge data for anti-replay protection. Ensures proofs cannot be reused in different contexts.

##### `challenge.nonce` (string)

- **Type**: String (base64-encoded)
- **Description**: Cryptographic nonce for anti-replay protection
- **Encoding**: Base64
- **Size**: Typically 16-32 bytes
- **Generation**: Created by the validator or provided by the customer at proof generation time
- **Usage**: The nonce binds the proof to a specific validation request

**Example:**
```json
"nonce": "MTIzNDU2Nzg5MGFiY2RlZg=="
```

##### `challenge.issuedAt` (string, ISO 8601)

- **Type**: String (ISO 8601 datetime)
- **Description**: Timestamp indicating when the challenge was issued
- **Format**: ISO 8601 with milliseconds and UTC timezone
- **Usage**: Used for time-based validation and audit logging

**Example:**
```json
"issuedAt": "2026-02-07T13:00:00.000Z"
```

##### `challenge.expiresAt` (string, ISO 8601)

- **Type**: String (ISO 8601 datetime)
- **Description**: Timestamp indicating when the challenge expires
- **Format**: ISO 8601 with milliseconds and UTC timezone
- **Usage**: After this time, the proof is considered expired and must be regenerated. The validator will reject expired proofs.
- **Typical TTL**: 24 hours to 7 days

**Example:**
```json
"expiresAt": "2026-02-08T13:00:00.000Z"
```

### Optional Fields

#### `version` (string)

- **Type**: String (semver)
- **Description**: Proof envelope format version for backward compatibility
- **Default**: "1.0.0" if not specified
- **Usage**: Allows future envelope format upgrades while maintaining compatibility

**Example:**
```json
"version": "1.0.0"
```

#### `metadata` (object)

- **Type**: Object (extensible)
- **Description**: Optional metadata for additional context, debugging, and future enhancements
- **Validation**: Not validated cryptographically by the proof system
- **Usage**: For operational visibility, troubleshooting, and extensibility

**Common metadata fields:**

##### `metadata.generatedAt` (string, ISO 8601)

Timestamp when the proof was generated by the customer's proof server.

```json
"generatedAt": "2026-02-07T13:15:00.000Z"
```

##### `metadata.proofServerVersion` (string)

Version of the Midnight proof server used to generate this proof. Useful for debugging format compatibility issues.

```json
"proofServerVersion": "0.16.0"
```

##### `metadata.tier` (string)

License tier (e.g., "community", "professional", "enterprise"). This is informational only and must match the tier proven in the proof bytes.

```json
"tier": "professional"
```

##### `metadata.features` (array of strings)

List of enabled feature flags. Informational only; the cryptographic proof attests to the actual features.

```json
"features": ["api-access", "advanced-analytics", "priority-support"]
```

##### `metadata.customerId` (string)

Optional customer identifier for tracking and support purposes.

```json
"customerId": "customer-abc-123"
```

## Complete Example

```json
{
  "$schema": "../../../policies/schemas/proof-envelope.schema.json",
  "version": "1.0.0",
  "proofBytes": "AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8w...",
  "verificationKeyBytes": "gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6v...",
  "productId": "chainborn-sample-app",
  "challenge": {
    "nonce": "MTIzNDU2Nzg5MGFiY2RlZg==",
    "issuedAt": "2026-02-07T13:00:00.000Z",
    "expiresAt": "2026-02-08T13:00:00.000Z"
  },
  "metadata": {
    "generatedAt": "2026-02-07T13:15:00.000Z",
    "proofServerVersion": "0.16.0",
    "tier": "professional",
    "features": ["api-access", "advanced-analytics", "priority-support"],
    "customerId": "customer-abc-123"
  }
}
```

## How the Envelope is Produced

### 1. Customer Proof Generation (Client-Side)

Customers generate proofs using the Chainborn License CLI tool, which wraps the Midnight SDK:

```bash
# Start the Midnight proof server (required for proof generation)
midnight proof-server start

# Generate a license proof
chainborn-license generate-proof \
  --wallet ./wallet.json \
  --product chainborn-sample-app \
  --challenge $(cat challenge.txt) \
  --output license-proof.json

# The output is a complete proof envelope in JSON format
```

**Key points:**
- Proof generation is always **client-side** to preserve customer privacy
- The vendor never sees the customer's wallet or private state
- Proofs are portable and can be transferred to runtime environments

### 2. Challenge Generation (Optional)

For enhanced security, the application can generate and provide a challenge nonce:

```bash
# Application generates a challenge
openssl rand -base64 32 > challenge.txt

# Customer uses this challenge when generating the proof
chainborn-license generate-proof \
  --challenge $(cat challenge.txt) \
  ...
```

If no challenge is provided, the CLI generates a default challenge.

## How the Envelope is Consumed

The proof envelope can be loaded from multiple sources in order of precedence:

### 1. Environment Variable: `LICENSE_PROOF`

Recommended for Kubernetes secrets and simple Docker deployments:

```bash
# Load proof inline
docker run -e LICENSE_PROOF='{"proofBytes":"...","verificationKeyBytes":"..."}' myapp:latest

# Load from file in shell
docker run -e LICENSE_PROOF="$(cat license-proof.json)" myapp:latest
```

**Pros:**
- Simple for containerized environments
- Works well with Kubernetes ConfigMaps and Secrets
- No file mounting required

**Cons:**
- Environment variables have size limits (typically ~128 KB)
- Proof bytes may exceed limits for very large proofs

### 2. File Path: `LICENSE_PROOF_FILE`

Recommended for air-gapped deployments and large proofs:

```bash
# Mount proof file as a volume
docker run \
  -v /path/to/license-proof.json:/etc/chainborn/proof.json \
  -e LICENSE_PROOF_FILE=/etc/chainborn/proof.json \
  myapp:latest
```

**Kubernetes example:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: LICENSE_PROOF_FILE
      value: /etc/chainborn/proof.json
    volumeMounts:
    - name: license-proof
      mountPath: /etc/chainborn/proof.json
      subPath: proof.json
      readOnly: true
  volumes:
  - name: license-proof
    secret:
      secretName: license-proof-secret
```

**Pros:**
- No size limits
- More secure (proof not visible in process environment)
- Works well with volume mounts and Kubernetes secrets

**Cons:**
- Requires file system access
- More complex setup than environment variables

### 3. Default Location: `/etc/chainborn/proof.json`

If neither `LICENSE_PROOF` nor `LICENSE_PROOF_FILE` is set, the validator checks the default location:

```bash
# Simply mount the proof at the default location
docker run -v /path/to/license-proof.json:/etc/chainborn/proof.json myapp:latest
```

**Pros:**
- Simplest configuration (no environment variables needed)
- Convention-based approach

**Cons:**
- Less flexible
- May conflict with file system permissions

### 4. CLI Override

For development and testing, the CLI can override proof sources:

```bash
# Use a custom proof file
myapp --license-proof /path/to/custom-proof.json

# Or specify inline JSON
myapp --license-proof-json '{"proofBytes":"...","verificationKeyBytes":"..."}'
```

## Loader Precedence (Issue #13)

The .NET validator will implement proof loading in the following order:

1. **CLI arguments** (if provided via `--license-proof` or `--license-proof-json`)
2. **`LICENSE_PROOF` environment variable** (inline JSON)
3. **`LICENSE_PROOF_FILE` environment variable** (file path)
4. **Default location** `/etc/chainborn/proof.json`

If none of these sources provide a valid proof, the validator will return an error and fail startup or validation.

## Security Considerations

### ⚠️ Sensitive Data Handling

**Proof bytes are sensitive and should be treated like API keys or credentials.**

#### DO:
- ✅ Load proofs from environment variables or mounted volumes
- ✅ Use Kubernetes secrets for production deployments
- ✅ Restrict file permissions on proof files (e.g., `chmod 600`)
- ✅ Rotate proofs regularly based on TTL
- ✅ Use HTTPS when transferring proof envelopes
- ✅ Validate proof envelopes against the JSON schema before processing

#### DO NOT:
- ❌ Log proof bytes or verification keys in production
- ❌ Commit proof files to version control
- ❌ Share proofs across different products or environments
- ❌ Reuse expired proofs
- ❌ Transmit proofs over unencrypted channels
- ❌ Store proofs in publicly accessible locations

### Kubernetes Secrets Example

Create a Kubernetes secret from a proof file:

```bash
# Create secret from proof file
kubectl create secret generic license-proof-secret \
  --from-file=proof.json=license-proof.json

# Mount in deployment
kubectl create deployment myapp \
  --image=myapp:latest \
  --dry-run=client -o yaml | \
  kubectl patch -f - --type=json -p='[
    {
      "op": "add",
      "path": "/spec/template/spec/volumes",
      "value": [{"name": "license-proof", "secret": {"secretName": "license-proof-secret"}}]
    },
    {
      "op": "add",
      "path": "/spec/template/spec/containers/0/volumeMounts",
      "value": [{"name": "license-proof", "mountPath": "/etc/chainborn/proof.json", "subPath": "proof.json", "readOnly": true}]
    }
  ]' | kubectl apply -f -
```

## Validation and Testing

### Schema Validation

All proof envelopes should be validated against the JSON schema:

```bash
# Install a JSON schema validator (example: ajv-cli)
npm install -g ajv-cli

# Validate a proof envelope
ajv validate \
  -s policies/schemas/proof-envelope.schema.json \
  -d tests/fixtures/valid-proof-envelope.json

# Should output: valid
```

### Test Fixtures

Test fixtures are provided in `tests/fixtures/`:

1. **`valid-proof-envelope.json`**: Example of a properly formatted, unexpired proof envelope
2. **`expired-proof-envelope.json`**: Example of a proof envelope with an expired challenge (expiresAt in the past)

These fixtures:
- Validate against the JSON schema
- Demonstrate correct field usage
- Serve as integration test inputs
- Can be used for documentation and examples

### Automated Tests

The validator should include automated tests for:

- ✅ Schema validation for all test fixtures
- ✅ Successful loading from each proof source (env var, file, default location)
- ✅ Rejection of expired proofs based on `challenge.expiresAt`
- ✅ Rejection of malformed JSON or invalid base64 encoding
- ✅ Rejection of proofs with mismatched `productId`
- ✅ Correct precedence when multiple proof sources are provided

## Integration with Issue #13 (Proof Loader)

The proof loader implementation should:

1. **Support all three proof sources** with correct precedence:
   - Environment variable: `LICENSE_PROOF`
   - File path: `LICENSE_PROOF_FILE`
   - Default location: `/etc/chainborn/proof.json`

2. **Validate proof envelopes** against the JSON schema before processing

3. **Handle errors gracefully**:
   - Missing proof sources
   - Invalid JSON
   - Schema validation failures
   - File system errors
   - Base64 decoding errors

4. **Provide clear error messages** for troubleshooting:
   ```
   ERROR: Failed to load license proof
   - Checked LICENSE_PROOF: not set
   - Checked LICENSE_PROOF_FILE: not set
   - Checked /etc/chainborn/proof.json: file not found
   Solution: Provide proof via environment variable or mount proof file
   ```

5. **Log proof source** (but NOT proof bytes) for audit and debugging:
   ```
   INFO: License proof loaded from environment variable LICENSE_PROOF
   INFO: Proof valid for product: chainborn-sample-app
   INFO: Challenge expires at: 2026-02-08T13:00:00.000Z
   ```

6. **CLI override support**:
   ```bash
   myapp --license-proof /custom/path/proof.json
   myapp --license-proof-json '{"proofBytes":"...","verificationKeyBytes":"..."}'
   ```

### Example Loader Interface (C#)

```csharp
public interface IProofEnvelopeLoader
{
    /// <summary>
    /// Loads a proof envelope from configured sources in order of precedence.
    /// </summary>
    /// <param name="options">Optional loader configuration</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Loaded and validated proof envelope</returns>
    /// <exception cref="ProofLoadException">If proof cannot be loaded or is invalid</exception>
    Task<ProofEnvelope> LoadAsync(
        ProofLoaderOptions? options = null,
        CancellationToken cancellationToken = default);
}

public class ProofLoaderOptions
{
    /// <summary>
    /// Override CLI argument for proof file path
    /// </summary>
    public string? ProofFilePath { get; set; }
    
    /// <summary>
    /// Override CLI argument for inline proof JSON
    /// </summary>
    public string? ProofJson { get; set; }
}
```

## Extensibility and Future Enhancements

The proof envelope format is designed for extensibility:

### Version Field

The optional `version` field allows future format changes:

```json
{
  "version": "2.0.0",
  "proofBytes": "...",
  // New fields in version 2.0.0
  "circuitId": "license-v2",
  "publicInputs": { ... }
}
```

Validators should check the version field and:
- Support all backward-compatible versions
- Reject unsupported future versions with clear error messages
- Log warnings for deprecated versions

### Metadata Extensibility

The `metadata` object supports arbitrary additional fields:

```json
{
  "metadata": {
    "generatedAt": "2026-02-07T13:15:00.000Z",
    // Vendor-specific fields
    "cloudProvider": "AWS",
    "region": "us-east-1",
    "deploymentId": "d-1234567890",
    // Future ZK enhancements
    "aggregatedProof": false,
    "recursiveProofDepth": 0
  }
}
```

### Protocol Upgrades

When Midnight protocol upgrades change proof formats:

1. **Add protocol version to metadata**:
   ```json
   "metadata": {
     "midnightProtocolVersion": "genesis-mainnet-1.0",
     "proofSystem": "groth16",
     "curve": "bls12-381"
   }
   ```

2. **Update schema** to version 2.0.0 with new required fields

3. **Maintain backward compatibility** by supporting both formats during a transition period

4. **Provide migration tools** to convert old proofs to new format (if feasible)

## Cross-References

### Related Schemas
- [License Policy Schema](../policies/schemas/license-policy.schema.json) - Defines validation policies
- [Proof Envelope Schema](../policies/schemas/proof-envelope.schema.json) - This schema

### Related Documentation
- [Architecture](architecture.md) - System design and bridge point
- [Spike #2: Wallet Interaction](spikes/spike-002-wallet-interaction.md) - Proof generation workflows
- [Spike #3: ZK Proof .NET Verification](spikes/spike-003-zk-proof-dotnet.md) - Verification strategies
- [Policy Schema Documentation](policy-schema.md) - License policy validation

### Related Issues
- Issue #12: Establish JSON envelope format (this document)
- Issue #13: Implement proof loader with multiple source support

## Changelog

### Version 1.0.0 (2026-02-07)
- Initial proof envelope schema and documentation
- Test fixtures for valid and expired proofs
- Integration plan for loader implementation (issue #13)
