# Proof Envelope Format

## Overview

The **Proof Envelope** is the canonical JSON format for distributing Midnight license proofs in a portable, secure, and extensible manner. It wraps zero-knowledge proof data with the metadata needed for offline validation in .NET applications.

## Purpose

The proof envelope enables:

- **Portable proof distribution**: move proofs from a customer proof-generation environment to runtime containers
- **Offline validation**: verify licenses locally without external API calls
- **Anti-replay protection**: challenge/nonce mechanism prevents proof reuse
- **Extensibility**: future ZK system upgrades and metadata fields
- **Multi-source loading**: load proofs from env vars, files, or Kubernetes secrets

## Schema Reference

The canonical JSON Schema is located at:

`policies/schemas/proof-envelope.schema.json`

All proof envelopes **MUST** validate against this schema before being processed by the .NET validator.

---

## Canonical JSON Shape

This repo uses a **flat envelope** (no nested `proof` object):

```json
{
  "$schema": "../policies/schemas/proof-envelope.schema.json",
  "version": "1.0.0",
  "proofBytes": "<base64>",
  "verificationKeyBytes": "<base64>",
  "productId": "your-product-id",
  "challenge": {
    "nonce": "<base64>",
    "issuedAt": "2026-02-07T13:00:00.000Z",
    "expiresAt": "2026-02-08T13:00:00.000Z"
  },
  "metadata": {
    "generatedAt": "2026-02-07T13:15:00.000Z",
    "proofServerVersion": "0.16.0",
    "tier": "professional",
    "features": ["api-access", "advanced-analytics"],
    "customerId": "customer-abc-123"
  }
}
````

Notes:

* `proofBytes` and `verificationKeyBytes` are **base64 strings** inside JSON.
* `LICENSE_PROOF` (when used) contains **inline JSON** (not base64-encoded JSON).

---

## Field Definitions

### Required Fields

#### `proofBytes` (string, base64)

* The zk proof bytes (e.g., Groth16 proof)
* **Security**: sensitive; do not log in production

Example:

```json
"proofBytes": "AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8w..."
```

#### `verificationKeyBytes` (string, base64)

* Verification key bytes for the circuit used to generate `proofBytes`
* Typically bundled with the application or deployed alongside it

Example:

```json
"verificationKeyBytes": "gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp..."
```

#### `productId` (string)

* Product identifier this proof is valid for
* Used to prevent cross-product reuse

Example:

```json
"productId": "chainborn-sample-app"
```

#### `challenge` (object)

Anti-replay binding. A proof is tied to a specific challenge.

##### `challenge.nonce` (string, base64)

* Cryptographic nonce (typically 16–32 bytes)
* Generated by validator or provided at proof generation time

Example:

```json
"nonce": "MTIzNDU2Nzg5MGFiY2RlZg=="
```

##### `challenge.issuedAt` (string, ISO 8601)

Example:

```json
"issuedAt": "2026-02-07T13:00:00.000Z"
```

##### `challenge.expiresAt` (string, ISO 8601)

Example:

```json
"expiresAt": "2026-02-08T13:00:00.000Z"
```

### Optional Fields

#### `version` (string, semver)

* Default: `"1.0.0"` if omitted
* Used for forward/backward compatibility

Example:

```json
"version": "1.0.0"
```

#### `metadata` (object)

* Extensible operational metadata (not cryptographically verified unless the circuit proves it)
* Use for troubleshooting/auditing context, not authorization

---

## Complete Example

```json
{
  "$schema": "../policies/schemas/proof-envelope.schema.json",
  "version": "1.0.0",
  "proofBytes": "AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8w...",
  "verificationKeyBytes": "gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6v...",
  "productId": "chainborn-sample-app",
  "challenge": {
    "nonce": "MTIzNDU2Nzg5MGFiY2RlZg==",
    "issuedAt": "2026-02-07T13:00:00.000Z",
    "expiresAt": "2026-02-08T13:00:00.000Z"
  },
  "metadata": {
    "generatedAt": "2026-02-07T13:15:00.000Z",
    "proofServerVersion": "0.16.0",
    "tier": "professional",
    "features": ["api-access", "advanced-analytics", "priority-support"],
    "customerId": "customer-abc-123"
  }
}
```

---

## How the Envelope is Produced

### 1. Customer Proof Generation (Client-Side)

Customers generate proofs using the License CLI (wrapping the Midnight SDK):

```bash
midnight proof-server start

chainborn-license generate-proof \
  --wallet ./wallet.json \
  --product chainborn-sample-app \
  --challenge "$(cat challenge.txt)" \
  --output license-proof.json
```

Key points:

* Proof generation is **client-side** to preserve customer privacy
* Vendor never sees the wallet or private state
* Result is a **proof envelope JSON** ready for transport

### 2. Challenge Generation (Optional)

```bash
openssl rand -base64 32 > challenge.txt
```

If no challenge is provided, the CLI may generate a default challenge (depending on implementation).

---

## How the Envelope is Consumed

### Loader Precedence

The .NET validator loads the proof in this order:

1. **CLI arguments** (e.g., `--license-proof` or `--license-proof-json`)
2. **`LICENSE_PROOF` environment variable** (**inline JSON**, not base64-encoded JSON)
3. **`LICENSE_PROOF_FILE` environment variable** (file path)
4. **Default location**: `/etc/chainborn/proof.json`

If none provide a valid proof envelope, validation fails with a clear error.

---

## Loading Sources

### 1. Environment Variable: `LICENSE_PROOF` (inline JSON)

Recommended for Kubernetes secrets (as env var) and simple Docker deployments.

```bash
docker run -e LICENSE_PROOF='{"proofBytes":"...","verificationKeyBytes":"...","productId":"...","challenge":{"nonce":"...","issuedAt":"...","expiresAt":"..."}}' myapp:latest

docker run -e LICENSE_PROOF="$(cat license-proof.json)" myapp:latest
```

Pros:

* Simple container configuration
* Works with Kubernetes Secrets (as env vars) when size allows

Cons:

* Environment variable size limits (often ~128 KB)
* JSON-in-env is easier to accidentally leak via process inspection compared to file mounts

### 2. File Path: `LICENSE_PROOF_FILE`

Recommended for production, air-gapped deployments, and large proofs.

```bash
docker run \
  -v /path/to/license-proof.json:/etc/chainborn/proof.json:ro \
  -e LICENSE_PROOF_FILE=/etc/chainborn/proof.json \
  myapp:latest
```

### 3. Default Location: `/etc/chainborn/proof.json`

```bash
docker run -v /path/to/license-proof.json:/etc/chainborn/proof.json:ro myapp:latest
```

### 4. CLI Overrides (Dev/Test)

```bash
myapp --license-proof /path/to/custom-proof.json
myapp --license-proof-json '{"proofBytes":"...","verificationKeyBytes":"...","productId":"...","challenge":{"nonce":"...","issuedAt":"...","expiresAt":"..."}}'
```

---

## Kubernetes Integration

### Using Secrets (Recommended)

Create a Secret from a proof file:

```bash
kubectl create secret generic license-proof-secret \
  --from-file=proof.json=./license-proof.json
```

Mount as a file:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: LICENSE_PROOF_FILE
      value: /etc/chainborn/proof.json
    volumeMounts:
    - name: license-proof
      mountPath: /etc/chainborn/proof.json
      subPath: proof.json
      readOnly: true
  volumes:
  - name: license-proof
    secret:
      secretName: license-proof-secret
```

Or inject as environment variable (only if size allows):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: LICENSE_PROOF
      valueFrom:
        secretKeyRef:
          name: license-proof-secret
          key: proof.json
```

### Using ConfigMaps (Not Recommended for Production)

ConfigMaps are not appropriate for sensitive proofs (use Secrets for prod):

```bash
kubectl create configmap license-proof \
  --from-file=proof.json=./license-proof.json
```

---

## Docker Compose Examples

### Volume Mount

```yaml
version: "3.8"
services:
  app:
    image: myapp:latest
    environment:
      - LICENSE_PROOF_FILE=/etc/chainborn/proof.json
    volumes:
      - ./license-proof.json:/etc/chainborn/proof.json:ro
```

### Environment Variable (inline JSON)

```yaml
version: "3.8"
services:
  app:
    image: myapp:latest
    environment:
      - LICENSE_PROOF=${LICENSE_PROOF}
```

Then:

```bash
export LICENSE_PROOF="$(cat license-proof.json)"
docker-compose up
```

---

## Security Considerations

### Sensitive Data Handling

Proof bytes (and often verification keys) should be treated like credentials.

DO:

* ✅ Prefer Kubernetes **Secrets**
* ✅ Prefer file mounts for production and/or large proofs
* ✅ Use read-only mounts and strict file permissions
* ✅ Validate against JSON schema before processing
* ✅ Reject expired challenges (`challenge.expiresAt`)
* ✅ Log *source* and high-level info (never proof bytes)

DO NOT:

* ❌ Log `proofBytes` / `verificationKeyBytes`
* ❌ Commit proofs to version control
* ❌ Share proofs across products/environments
* ❌ Reuse expired proofs
* ❌ Transmit proofs over unencrypted channels
* ❌ Base64-encode the entire JSON payload for `LICENSE_PROOF` (it harms debuggability and increases accidental leakage risk)

---

## Error Handling

The loader should return clear errors. Example:

### No Proof Found

```
No proof envelope found. Checked:
1) CLI arguments
2) LICENSE_PROOF
3) LICENSE_PROOF_FILE
4) /etc/chainborn/proof.json
```

### Invalid JSON

```
Failed to deserialize proof envelope JSON.
```

### Schema Validation Failure

```
Proof envelope failed schema validation: missing required field 'challenge.expiresAt'.
```

### Invalid Base64 in Fields

```
Invalid base64 in field 'proofBytes'.
```

### File Not Found

```
Proof file not found: /custom/path/proof.json
```

---

## Validation and Testing

### Schema Validation (Example using ajv)

```bash
npm install -g ajv-cli ajv-formats

ajv validate \
  -s policies/schemas/proof-envelope.schema.json \
  -d tests/fixtures/valid-proof-envelope.json \
  --spec=draft7 \
  -c ajv-formats
```

### Test Fixtures

`tests/fixtures/` should include:

1. `valid-proof-envelope.json`
2. `expired-proof-envelope.json`

Recommended tests:

* ✅ Loading from each source (CLI/env/file/default)
* ✅ Precedence correctness
* ✅ Reject expired proofs
* ✅ Reject malformed JSON / invalid base64
* ✅ Reject mismatched `productId`

---

## Extensibility

### Versioning

The `version` field enables future upgrades:

```json
{
  "version": "2.0.0",
  "proofBytes": "...",
  "verificationKeyBytes": "...",
  "productId": "...",
  "challenge": { "nonce": "...", "issuedAt": "...", "expiresAt": "..." },
  "metadata": {
    "midnightProtocolVersion": "genesis-mainnet-1.0",
    "proofSystem": "groth16",
    "curve": "bls12-381"
  }
}
```

Validators should:

* support known versions
* reject unsupported future versions with clear messages
* warn on deprecated versions when needed

---

## Cross-References

Related schemas:

* `policies/schemas/license-policy.schema.json`
* `policies/schemas/proof-envelope.schema.json`

Related docs:

* `architecture.md`
* `spikes/spike-002-wallet-interaction.md`
* `spikes/spike-003-zk-proof-dotnet.md`
* `policy-schema.md`

Related issues:

* Issue #12: Establish JSON envelope format (this document)
* Issue #13: Implement proof loader with multiple source support

---

## Changelog

### 1.0.0 (2026-02-07)

* Initial proof envelope schema and documentation
* Test fixtures for valid and expired envelopes
* Loader precedence and deployment patterns